{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>P4 Drawing</title>

    <link rel="stylesheet" type="text/css" href="{% static 'draw/vendor/bootstrap/css/bootstrap.min.css' %}">
    <script type="text/javascript" src="{% static 'draw/vendor/jquery/jquery-3.3.1.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'draw/vendor/paper/paper-full.min.js' %}"></script>
  <script type="text/javascript" src="https://cdn.rawgit.com/alexgibson/shake.js/master/shake.js"></script>
  

    <style type="text/css">
      
      /* Body element, flex display, justify content center, to center all following content*/
      body {
        display: flex;
        justify-content: center;
        flex-direction: column;
        
        
      }
      #myCanvas {
        height: 700px;
        width: 95%;
        margin: 0 auto;
      }
      
      /* This will be the bar to choose legos to drop onto the screen. */
      .legoBAR {
        margin-top: 20px;
        border: 2px solid blue;
        width: 95%;
        height:200px;
        margin-left: 30px;
        
        display: flex;
        justify-content: space-around;
      }
      
      .legoItem {
        height: 125px;
        width: 125px;
        margin-top:35px;
        display: flex;
        color: gold;
        flex-direction: column;
        justify-content: space-between;
        
        
      }
      
      .buttonContainer {
        margin: 0 auto;
        margin-bottom: 20px;
        
        width: 95%;
        display: flex;
        flex-direction: row;
        justify-content:space-around;
        margin-top: 20px;
      }
      
      .imageContainer {
        border: 2px solid green;
        margin-left: 30px;
        width: 80%;
        display: flex;
        margin-top: 10px;
        justify-content: space-evenly;
      }
      
      
    </style>

</head>
<body>
    <!-- You may change the dimensions of this canvas -->
    <canvas id="myCanvas"></canvas>
  
  <!--The "toolbar" which holds the different types of legos, div classes currently have placeholders,
        they will have buttons eventually which create new paper objects maybe in the bottom corner, and an undo button-->
  
  <div class="buttonContainer">
    <button onclick="createLargePiece()" class="largepiece">
         Large LEGO
      </button>
    <button onclick="createMidPiece()" class="largepiece">
         Medium LEGO
      </button>
    <button onclick="createSmallPiece()" class="largepiece">
         Small LEGO
      </button>
    <button onclick="createLargeSquare()" class="largepiece">
         Large Square
      </button>
    <button onclick="createSmallSquare()" class="largepiece">
         Small Square
      </button>
    
    <!--
    <button onclick="undo()">
         Undo
      </button> -->
    
  </div>
  <!--  ** Scrapping for now, not lining up visually and spending too much time on this **
  <div class="imageContainer">
    
    
    <div class="largeImage imageForClick"></div>
    <div class="mediumImage imageForClick"></div>
    <div class="smallImage imageForClick"></div>
    <div class="largeSimage imageForClick"></div>
    <div class="smallSimage imageForClick"></div>
    
    
    
  </div>
  -->
  
</body>
<script>
  
  //*** server is running HERE: http://p3-websockets-dpayne5-dpayne589733.codeanyapp.com:3000/draw/ *********

  var allLEGOS = [];
  var canvas = document.getElementById('myCanvas');
  var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');

  paper.setup(canvas);
  var tool = new paper.Tool();
  
  paper.view.draw();
  
  var segment, path;
  var movePath = false;
  
  // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  
  
  function makeFlagArray(index) {
    var flag = [index];
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    return flag;
    
  }
  
  //this is to combine two shapes together
  //  result = square[operation](ring);
  function makeMouseDownSocketArray(event) {
    var flag = [-1];
    flag.push(event.point.x);
    flag.push(event.point.y);
    flag.push(event.point);
    flag.push(event.modifiers.shift);
    flag.push(segment);
    flag.push(path);
    flag.push(movePath);
    flag.push(allLEGOS);
    
    return flag;
    
  }
  
  function createLargePiece() {
    socket.send(JSON.stringify(makeFlagArray(1))); 
  }
  
  
  function createSmallPiece() {
    socket.send(JSON.stringify(makeFlagArray(2))); 
  }
  
  function createMidPiece() {
    socket.send(JSON.stringify(makeFlagArray(3))); 
  }
  
  function createLargeSquare() {
    socket.send(JSON.stringify(makeFlagArray(4))); 
  }
  
  function createSmallSquare() {
    socket.send(JSON.stringify(makeFlagArray(5))); 
  }
  
  function undo() {
    socket.send(JSON.stringify(makeFlagArray(6))); 
  }
 
  //socket function, intended to be VERY large. Has switch cases for just about everything
  socket.onmessage = function(data) {
    
    var s = JSON.parse(data.data);
    console.log("parsing the info from new function");
    console.log(s);
    
    var x = parseInt(s[1]);
    var y = parseInt(s[2]);
    
    //generate random colors function
    function getRandomColor() {
      var options = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += options[Math.floor(Math.random() * 16)];
      }
      return color;
    }
    
    switch (parseInt(s[0])) {
      case 1:
        var newLP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(400,50));
        newLP.fillColor = 'black';
        allLEGOS.push(newLP);
        //s[3].push(newLP);
        
        //return newLP;
        //now a new problem, we can return; but returning gives us a null item for some reason
        //NEED to get the items in allLEGOS somehow
        break;
      case 2:
        //do stuff
        var newMP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,50));
        newMP.fillColor = 'black';
        s[3].push(newMP);
        return newMP;
        break;
      case 3:
        //do stuff
        var newSP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,50));
        newSP.fillColor = 'black';
        s[3].push(newMP);
        return newSP;
        break;
      case 4:
        //do stuff
        var newLS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,200));
        s[3].push(newLS);
        newLS.fillColor = 'black';
        return newLS;
        break;
      case 5:
        //do stuff
        var newSS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,100));
        s[3].push(newSS);
        newSS.fillColor = 'black';
        return newSS;
        break;
      case 6:
        // *** currently the undo button does NOT work
        //do stuff
        //console.log("undo works");
        //allLEGOS[allLEGOS.length -1].fillColor = 'white';
        s[3][s[3].length -1].fillColor = 'white';
        var toDelete = s[3].pop();
        var toDelete = new paper.Path;
        
        
        break;
        
        
      case -1:
        //I wonder if we have to do things INSIDE of this function for scoping issues?
        //trying something here, to see if scoping is the issue, although I doubt it.
        
        //we know that s[8] contains items, which is good
        segment = path = null;
    
        //********** BIG STICKING POINT, ~6 HOURS NOW
    var hitResult = paper.project.hitTest(s[3], hitOptions);
    //before was event.point
    
    if (!hitResult) {
      console.log("nothing hit");
      return [null, null, false];
    }
    if (s[4]) { //before was event.modifiers
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
      console.log("HIT RESULT DATA");
      console.log(hitResult.item);
		path = hitResult.item;
      console.log("AFTER PATH GETS ASSIGNED TO");
      console.log(path)
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, eventpoint);  //before was event.point
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, eventpoint); //before wa event.point
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    paper.view.draw();
    
    //need to return [segment, path, movepath]
        
        break;
      case -2:
        //here we do things for mouseDrag
        console.log("in the socketMOUSEDRAG");
        socketMOUSEDRAG(s[4], s[3], s[5], s[6]);
        break;
        
      default:
        console.log("nothing happened");
        
        
    }
    
  }
  
  
  paper.view.draw();
  //variables for movement abilities
  
  
  
  var hitOptions = {
	segments: true,
	stroke: true,
	fill: true,
	tolerance: 10
  };
  
  
  //rolling mouseDown into one function, for websocket
  //needs to return segment, path, and movepath
  function socketMOUSEDOWN(eventpoint, modifiers, segment, path, movePath, allLEGOS) {
    segment = path = null;
    
    
    var hitResult = paper.project.hitTest(eventpoint, hitOptions);
    //before was event.point
    
    if (!hitResult) {
      console.log("nothing hit");
      return [null, null, false];
    }
    if (modifiers) { //before was event.modifiers
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
      console.log("HIT RESULT DATA");
      console.log(hitResult.item);
		path = hitResult.item;
      console.log("AFTER PATH GETS ASSIGNED TO");
      console.log(path)
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, eventpoint);  //before was event.point
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, eventpoint); //before wa event.point
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    paper.view.draw();
    
    //need to return [segment, path, movepath]
    console.log("BEFORE RETURN<> SEGMENT PATH movePAth: ", segment, path, movePath);
    return [segment, path, movePath];
  }
  
  
  
  tool.onMouseDown = function(event) {
    var s = event;

    socket.send(JSON.stringify(makeMouseDownSocketArray(s)));

    //Below is the original, which works only in your current browser!
    
    /*
    segment = path = null;
    
    
    var hitResult = paper.project.hitTest(event.point, hitOptions);
    //looking at results of hitResult;
    //here this is initialize {'fill } etc etc....so this is the problem
    console.log(hitResult);
    
    if (!hitResult) {
      return;
    }
    
    if (event.modifiers.shift) {
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, event.point);
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, event.point);
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    */
    
  }
  
  
  
  function socketMOUSEDRAG(eDelta, ePoint, segment, path) {
    if (segment) {
      segment.point += eDelta;
      path.smooth();
    }
    else if (path) {
      path.position = ePoint;
    }
    paper.view.draw();
  }
  
  function makeMouseDragSocketArray(event) {
    var flag = [-2];
    flag.push(event.point.x);
    flag.push(event.point.y);
    flag.push(event.point);
    flag.push(event.delta);
    flag.push(segment);
    flag.push(path);
    return flag;
    
  }
  
  //
  tool.onMouseDrag = function(event) {
    
    var s = JSON.stringify(makeMouseDragSocketArray(event));
    socket.send(s);
    //below this line is old, working code for one browser window only
    /*
    if (segment) {
      segment.point += event.delta;
      path.smooth();
    }
    else if (path) {
      path.position = event.point;
    }
    */
  }
  
  //old work from p3 implementations
  /*

    // setting up the canvas and one paper tool
    var canvas = document.getElementById('myCanvas');
    paper.setup(canvas);
    var tool = new paper.Tool();
  
  var count = 0;

    // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  console.log(url);

  
    var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');
    var colors = ['black', 'green', 'red', 'pink', 'orange', 'purple', 'magenta', 'cyan', 'blue', 'gray'];
    
  var publicPath = new paper.Path();
  var isSmall = false;
  
  
  //array of paths, for the multiple users, 
  var peopleArray = [];
  
  for (i = 0; i < colors.length; i++) {
    peopleArray.push(new paper.Path());
  }
  
  var randomIndex = Math.floor((Math.random() * 10000) % colors.length);
    //publicPath.strokeColor = colors[randomIndex];
  
  
  //1C implementation here
  
  
  
  if (url == "https://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/draw/?size-small") {
    console.log("small url")
    isSmall = true;
    
    for (i=0; i< peopleArray.length; i++) {
      if (i != randomIndex) {
        console.log("setting path visibility to false");
        peopleArray[i].visible = false;
      }
    }
    
    
  }
  
  tool.onMouseDown = function(event) {
    
    peopleArray[randomIndex] = new paper.Path();
    
    //here have to make another socket send to flag if the thing is small
    
    var oneCdata = "[" + -2 + "," + randomIndex + "]";
    console.log(oneCdata);
    
    socket.send(oneCdata)
    
  }
  
  tool.onMouseDrag = function(event) {
   // console.log("dragging");
    
      var d = JSON.stringify(event.point);
    //console.log(d);
      d = d.substring(0, d.length -1);
      d = d + ',"' + colors[randomIndex] + '",' + randomIndex +']';
    console.log(d);
    
      socket.send(d);
    

  }
  
  tool.onMouseUp = function(event) {
    //publicPath = new paper.Path();
    //publicPath.strokeColor = 'white';
    
    peopleArray[randomIndex] = new paper.Path();
    
    var passFlag = "["+ randomIndex + ',' + -1 + "]";
    console.log(passFlag);
    socket.send(passFlag);
    
    //on mouse Up send a thing to the other arrays, and make sure the new piece is cleared.
    
  }
  
    socket.onmessage = function(data) {
      var c = JSON.parse(data.data);
      
      console.log(count);
      console.log(data.data);
      
      
      if (c[0] == -2) {
        if (isSmall && c[1] != randomIndex) {
          peopleArray[c[1]].visible = false;
          
        }
      }
      
      if (c[1] == -1) {
        peopleArray[c[0]] = new paper.Path();
        return;
      }
      
      //console.log(publicPath.segments);
      
      if (count == 0) {
        peopleArray[c[4]] = new paper.Path();
        peopleArray[c[4]].strokeColor = 'white';
        
        
      }
      else if (count == 1) {
        peopleArray[c[4]].removeSegment(peopleArray[c[4]].segments.length -1);
      }
      else if (count > 1) {
        //var c = JSON.parse(data.data);
      console.log(c);
        console.log(c[4], c[3]);
      peopleArray[c[4]].strokeColor = c[3];
      peopleArray[c[4]].add(new paper.Point(c[1],c[2]));
        
        
        console.log(count);
        
      }
      
      
      count = count + 1;
      paper.view.draw();
      
      
    }
    */

</script>
</html>
