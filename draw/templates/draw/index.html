{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>P4 Drawing</title>

    <link rel="stylesheet" type="text/css" href="{% static 'draw/vendor/bootstrap/css/bootstrap.min.css' %}">
    <script type="text/javascript" src="{% static 'draw/vendor/jquery/jquery-3.3.1.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'draw/vendor/paper/paper-full.min.js' %}"></script>
  <script type="text/javascript" src="https://cdn.rawgit.com/alexgibson/shake.js/master/shake.js"></script>
  
    <style type="text/css">
      
      /* Body element, flex display, justify content center, to center all following content*/
      body {
        display: flex;
        justify-content: center;
        flex-direction: column;
    }
      #myCanvas {
        height: 700px;
        width: 95%;
        margin: 0 auto;
        background: linear-gradient(180deg, rgba(149, 147, 226, 0.83) 0%, rgba(212, 252, 221, 0.971139) 83.01%, #CDFCD7 99.99%, rgba(255, 255, 255, 0.78) 100%), #399E7A;
      }
      
      /* This will be the bar to choose legos to drop onto the screen. */
      .legoBAR {
        margin-top: 20px;
        border: 2px solid blue;
        width: 95%;
        height:200px;
        margin-left: 30px;
        
        display: flex;
        justify-content: space-around;
      }
      
      .legoItem {
        height: 125px;
        width: 125px;
        margin-top:35px;
        display: flex;
        color: gold;
        flex-direction: column;
        justify-content: space-between;
        
        
      }
      
      .buttonContainer {
        margin: 0 auto;
        margin-bottom: 20px;
        
        width: 95%;
        display: flex;
        flex-direction: row;
        justify-content:space-around;
        margin-top: 20px;
      }
      
      .imageContainer {
        border: 2px solid green;
        margin-left: 30px;
        width: 80%;
        display: flex;
        margin-top: 10px;
        justify-content: space-evenly;
      }
      
      
    </style>

</head>
<body>
    <!-- You may change the dimensions of this canvas -->
    <canvas id="myCanvas"></canvas>
  
  <!--The "toolbar" which holds the different types of legos, div classes currently have placeholders,
        they will have buttons eventually which create new paper objects maybe in the bottom corner, and an undo button-->
  
  <div class="buttonContainer">
    <button onclick="createLargePiece()" class="largepiece">
         Large LEGO
      </button>
    <button onclick="createMidPiece()" class="largepiece">
         Medium LEGO
      </button>
    <button onclick="createSmallPiece()" class="largepiece">
         Small LEGO
      </button>
    <button onclick="createLargeSquare()" class="largepiece">
         Large Square
      </button>
    <button onclick="createSmallSquare()" class="largepiece">
         Small Square
      </button>
    
    <!--
    <button onclick="undo()">
         Undo
      </button> -->
    
  </div>
  <!--  ** Scrapping for now, not lining up visually and spending too much time on this **
  <div class="imageContainer">
    
    
    <div class="largeImage imageForClick"></div>
    <div class="mediumImage imageForClick"></div>
    <div class="smallImage imageForClick"></div>
    <div class="largeSimage imageForClick"></div>
    <div class="smallSimage imageForClick"></div>
    
    
    
  </div>
  -->
  
</body>
<script>
  
  //*** server is running HERE: http://p3-websockets-dpayne5-dpayne589733.codeanyapp.com:3000/draw/ *********

  var allLEGOS = [];
  var canvas = document.getElementById('myCanvas');
  var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');

  paper.setup(canvas);
  var tool = new paper.Tool();
  
  paper.view.draw();
  
  var segment, path;
  var movePath = false;
  
  var hitOptions = {
	segments: true,
	stroke: true,
	fill: true,
	tolerance: 10
  };
  
    tool.onMouseDown = function(event) {
      
      /*
      //NEW THINGS HERE *********
      
      segment = path = null;
      var hitResult = paper.project.hitTest(event.point, hitOptions);
      
      if (!hitResult) {
          return;
          }
      
      //taken care of
      if (hitResult) {
        path = hitResult.item;
        //socket send hitResult.item;
        updateClientPath(hitResult.item); //currently doesnt work, gives back a different ID from the item imported, also not the same
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
        
        //socket send to make this happen across clients as well
      }
      
      // ******** END OF NEW THINGS
      
      */ 
      //OLD WORKING-ISH CODE BELOW ********
  
      var s = event;
    segment = path = null;
    
    
    var hitResult = paper.project.hitTest(event.point, hitOptions);
    
    //here
    
    console.log("HitResult :: ", hitResult);
   
    
    if (!hitResult) {
      return;
    }
    
    
    if (event.modifiers.shift) {
      
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
		if (hitResult.type == 'segment') {
      console.log("************EVENTMOD SEGMENT********")
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
      console.log("************EVENTMOD STROKE********")
			var location = hitResult.location;
			segment = path.insert(location.index + 1, event.point);
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      //need to send to the socket that path = this item *** IMPORTANT ***
      console.log("HIT RESULT ITEM IS:::", hitResult.item);
      //console.log(hitResult.item.id);
      console.log("HIT RESULT ITEM ID IS :::", hitResult.item.id);
      
      
      
      
      if (hitResult.type == 'segment') {
        console.log("************EVENTMOD SEGMENT********")
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stroke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, event.point);
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        console.log("************MOVECHILD LAYER********")
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    
      
      //END OF OLD WORKING CODE *********

    
  }
    
    
    
    
    function updateClientPath(hitResultPath) {
      var toPass = JSON.stringify(hitResultPath); //what we want to pass to the websocket
      console.log("THE PATH BEFORE ITS SENT ::: ", path);
      socket.send(toPass);
    }
  
  
    
    
    
    
    tool.onMouseDrag = function(event) {
      
      //segment piece not important
    if (segment) {
      segment.point += event.delta;
      path.smooth();
    }
      
      
      
    else if (path) {
      
      
      makeMouseDragTwo(event.point, path.id, path);
      //console.log("what is da path: " + path + " " + path.id);
      //path.position = event.point
      
    }
    
    
  }
    
    function makeMouseDragTwo(eventPoint, id, path) {
      var flag = [-2];
      flag.push(id);
      flag.push(eventPoint);
      flag.push(path);
      socket.send(JSON.stringify(flag));
      console.log("STRINGIFYD FOR FLAG OF MOUSEDRAG");
      console.log(JSON.stringify(flag));
  }

  // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  
  
  function makeFlagArray(index) {
    var flag = [index];
    console.log("what is this flag thingy: " + flag);
    console.log(typeof flag);
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    flag.push(getRandomID());
    console.log("flag after adding lego piece: " + flag)
    return flag;
    
    //ingraine color in the array here for consistent color wo breaking the code -__-  
  }
 
  function makeMouseDownSocketArray(event) {
    
    var test = "-1";
    test += event.point.toString();
    test += event.modifiers.shift.toString;
    test += event.item.toString();

    var flag = [-1];
    flag.push(event.point.x);
    flag.push(event.point.y);
    flag.push(event.point);
    flag.push(event.modifiers.shift);
    flag.push(segment);
    flag.push(path);
    flag.push(movePath);
    flag.push(allLEGOS);
    flag.push(event.item); //this is s[9]
    
    return flag;
    
  }
  
  function createLargePiece() {
    socket.send(JSON.stringify(makeFlagArray(1))); 
  }
  function createSmallPiece() {
    //console.log("printing out all lego arrays:" + allLEGOS);
    socket.send(JSON.stringify(makeFlagArray(2)));
    //console.log("after adding:" + allLEGOS);
  }
  function createMidPiece() {
    socket.send(JSON.stringify(makeFlagArray(3))); 
  }
  function createLargeSquare() {
    socket.send(JSON.stringify(makeFlagArray(4))); 
  }
  function createSmallSquare() {
    socket.send(JSON.stringify(makeFlagArray(5))); 
  }
  function undo() {
    socket.send(JSON.stringify(makeFlagArray(6))); 
  }
      
  //generate random colors function
  function getRandomColor() {
      var options = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += options[Math.floor(Math.random() * 16)];
      }
      return color;
    }
  
  //random ID generator
  function getRandomID() {
    var randID = Math.floor((Math.random() * 10000000) % 1000);
    return randID;
  }
  
  
  
  //socket function, intended to be VERY large. Has switch cases for just about everything
  socket.onmessage = function(data) {
    
    console.log("incoming data e.g: function(data) ::: ", data);
    
    var s = JSON.parse(data.data);
    
    console.log("data after JSON.parse(data.data) :::: ",s );
    
    if (s[0] == 'Path') {
      //path = paper.importJSON(data.data);
      paper.project.activeLayer.addChild(paper.importJSON(data.data));
      
    }
    
    var x = parseInt(s[1]);
    var y = parseInt(s[2]);
    
    switch (parseInt(s[0])) {
        //making a new LargeLego
      case 1:
        console.log(s);
        var newLP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(400,50));
        newLP.fillColor = getRandomColor();
        s[3].push(newLP);
        
        break;
        //making new medium lego
      case 2:
        //do stuff
        var newMP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,50));
        newMP.fillColor = getRandomColor();
        s[3].push(newMP);
        return newMP;
        break;
        //making new smallLego
      case 3:
        //do stuff
        var newSP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,50));
        newSP.fillColor = getRandomColor();
        s[3].push(newMP);
        return newSP;
        break;
        //making new LargeSquare
      case 4:
        //do stuff
        var newLS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,200));
        s[3].push(newLS);
        newLS.fillColor = getRandomColor();
        return newLS;
        break;
        //making new SmallSquare
      case 5:
        //do stuff
        var newSS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,100));
        s[3].push(newSS);
        newSS.fillColor = getRandomColor();
        return newSS;
        break;
        
        //undo button, currently not working
      case 6:
        
        s[3][s[3].length -1].fillColor = 'white';
        var toDelete = s[3].pop();
        var toDelete = new paper.Path;    
        break;

        //mouseDown socketSend
      case -1:
        socketMOUSEDOWN(s[3], s[4], s[5], s[6], s[7], s[8], s[9]);
        
        break;
        
        //mouseDrag socketSend
      case -2:
        
        console.log("path information :::: ",path);
        
        console.log(path.id) // the problem here is that path is UNDEFINED in the second window on the start.console
        //and when the item is created the path should be 
        
        //this line tells us that the s[3] data is a dictionary of sorts, ie ["path", {path data}]
        console.log("the path sent through comes in as this :::: ", s[3]);
        
        
        //if we create a new path object, it will be different from the original i believe, checking with s[3][1]
        console.log("index 1 of s[3] is :::: ", s[3][1]);
        
        //checking it as an item becomes .....
        var k = paper.importJSON(s[3][1]);
        
        //but I dont think this is an item..... At least its an item different looking from the path passed index
        
       
        

        var b = new paper.Point(s[2][1], s[2][2]); 
        var ID = s[1]
        console.log("ID SENT BY JSON IS::: ", ID);
        var newpath = paper.project.getItems({
        id: ID
        
      });
        
        //so this is making a new point, and then taking the ID, and getting the item based off of ID, and assigning
        //to it a new location. Now since this isnt *happening* on any screen, it must be getting the wrong ID,
        
        
        
        //*** testing path IDs
        
        
        path.position = b;
        
        newpath.position = b;
        
        
        
        break;
        
      default:
        
        
    }
    
  }
  
  
  paper.view.draw();
  //variables for movement abilities
  
  
  function socketMOUSEDOWN(eventpoint, modifiers, segment, path, movePath, allLEGOS, eventItem) {
    segment = path = null;
    
    //var hitResult = paper.project.hitTest(eventpoint, hitOptions);
    //before was event.point
    var hitResult = eventItem[1];
    
    if (!hitResult) {
      return [null, null, false];
    }
    if (modifiers) { //before was event.modifiers
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
      console.log("HIT RESULT ITEM IS ::: ", hitResult.item);
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, eventpoint);  //before was event.point
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, eventpoint); //before wa event.point
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    paper.view.draw();
    
    //need to return [segment, path, movepath]
    console.log("BEFORE RETURN<> SEGMENT PATH movePAth: ", segment, path, movePath);
    return [segment, path, movePath];
  }

  
  //
  
  
  
  
  
  

</script>
</html>
