{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>P4 Drawing</title>

    <link rel="stylesheet" type="text/css" href="{% static 'draw/vendor/bootstrap/css/bootstrap.min.css' %}">
    <script type="text/javascript" src="{% static 'draw/vendor/jquery/jquery-3.3.1.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'draw/vendor/paper/paper-full.min.js' %}"></script>
  <script type="text/javascript" src="https://cdn.rawgit.com/alexgibson/shake.js/master/shake.js"></script>
  

    <style type="text/css">
      
      /* Body element, flex display, justify content center, to center all following content*/
      body {
        display: flex;
        justify-content: center;
        flex-direction: column;
        
        
      }
      #myCanvas {
        height: 700px;
        width: 95%;
        margin: 0 auto;
      }
      
      /* This will be the bar to choose legos to drop onto the screen. */
      .legoBAR {
        margin-top: 20px;
        border: 2px solid blue;
        width: 95%;
        height:200px;
        margin-left: 30px;
        
        display: flex;
        justify-content: space-around;
      }
      
      .legoItem {
        height: 125px;
        width: 125px;
        margin-top:35px;
        display: flex;
        color: gold;
        flex-direction: column;
        justify-content: space-between;
        
        
      }
      
      .buttonContainer {
        margin: 0 auto;
        margin-bottom: 20px;
        
        width: 95%;
        display: flex;
        flex-direction: row;
        justify-content:space-around;
        margin-top: 20px;
      }
      
      .imageContainer {
        border: 2px solid green;
        margin-left: 30px;
        width: 80%;
        display: flex;
        margin-top: 10px;
        justify-content: space-evenly;
      }
      
      
    </style>

</head>
<body>
    <!-- You may change the dimensions of this canvas -->
    <canvas id="myCanvas"></canvas>
  
  <!--The "toolbar" which holds the different types of legos, div classes currently have placeholders,
        they will have buttons eventually which create new paper objects maybe in the bottom corner, and an undo button-->
  
  <div class="buttonContainer">
    <button onclick="createLargePiece()" class="largepiece">
         Large LEGO
      </button>
    <button onclick="createMidPiece()" class="largepiece">
         Medium LEGO
      </button>
    <button onclick="createSmallPiece()" class="largepiece">
         Small LEGO
      </button>
    <button onclick="createLargeSquare()" class="largepiece">
         Large Square
      </button>
    <button onclick="createSmallSquare()" class="largepiece">
         Small Square
      </button>
    
    <!--
    <button onclick="undo()">
         Undo
      </button> -->
    
  </div>
  <!--  ** Scrapping for now, not lining up visually and spending too much time on this **
  <div class="imageContainer">
    
    
    <div class="largeImage imageForClick"></div>
    <div class="mediumImage imageForClick"></div>
    <div class="smallImage imageForClick"></div>
    <div class="largeSimage imageForClick"></div>
    <div class="smallSimage imageForClick"></div>
    
    
    
  </div>
  -->
  
</body>
<script>
  
  var allLEGOS = [];
  var canvas = document.getElementById('myCanvas');
  var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');

  paper.setup(canvas);
  var tool = new paper.Tool();
  
  paper.view.draw();
  
  // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  
  
  function createLargePiece() {
    //first piece of data sent to socket message, ie case data[0] = 1, do etc....
    var flag = [1];
    //need to get the data of the pieces here, the event point coordinates and flag the socket to create
    //the piece at the coordinates
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    
    console.log(JSON.stringify(flag));
    
    //var s = flag.toString();
    socket.send(JSON.stringify(flag));
    
  }
  
  
  function createSmallPiece() {
    //socket send here
    var flag = [2]
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    //need to push their color as well
    flag.push(allLEGOS);
    socket.send(JSON.stringify(flag));
    
    
    
  }
  
  function createMidPiece() {
    var flag = [3];
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    socket.send(JSON.stringify(flag));
    //
  }
  
  function createLargeSquare() {
    var flag = [4];
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    socket.send(JSON.stringify(flag));
    //
  }
  
  function createSmallSquare() {
    var flag = [5];
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    socket.send(JSON.stringify(flag));
    
    
  }
  
  function undo() {
    var flag = [6];
    var s = flag.toString();
    //just sent to make the switdch statements less bulky
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    socket.send(JSON.stringify(flag));
    
    //delete last block made
  }
  
  
  /*
  //Pieces to use, assign these to an array later, or should add all these sizes to a dictionary
  var longPiece = new paper.Path.Rectangle(new paper.Point(200,300), new paper.Size(400,50));
  var midPiece = new paper.Path.Rectangle(new paper.Point(200,100), new paper.Size(200,50));
  var shortPiece = new paper.Path.Rectangle(new paper.Point(200,200), new paper.Size(100,50));
  var largeSquare = new paper.Path.Rectangle(new paper.Point(400,400), new paper.Size(200,200));
  var smallSquare = new paper.Path.Rectangle(new paper.Point(500,400), new paper.Size(200,200));
  */
  
  
  
  //socket function, intended to be VERY large. Has switch cases for just about everything
  socket.onmessage = function(data) {
    
    var s = JSON.parse(data.data);
    console.log(s);
    
    var x = parseInt(s[1]);
    var y = parseInt(s[2]);
    
    switch (parseInt(s[0])) {
      case 1:
        var newLP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(400,50));
        newLP.fillColor = 'black';
        s[3].push(newLP);
        console.log("looking at the items of s[3] now");
        console.log(s[3]);
        break;
      case 2:
        //do stuff
        var newMP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,50));
        newMP.fillColor = 'black';
        s[3].push(newMP);
        break;
      case 3:
        //do stuff
        var newSP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,50));
        newSP.fillColor = 'black';
        s[3].push(newMP);
        break;
      case 4:
        //do stuff
        var newLS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,200));
        s[3].push(newLS);
        newLS.fillColor = 'black';
        break;
      case 5:
        //do stuff
        var newSS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,100));
        s[3].push(newSS);
        newSS.fillColor = 'black';
        break;
      case 6:
        
        //do stuff
        //console.log("undo works");
        //allLEGOS[allLEGOS.length -1].fillColor = 'white';
        s[3][s[3].length -1].fillColor = 'white';
        var toDelete = s[3].pop();
        var toDelete = new paper.Path;
        
        console.log(toDelete);
        
        break;
      default:
        console.log("nothing happened");
        
        
    }
    
  }
  
  
  
  //commented out below is an attempt at a half circle/cap. Going to come back to it.
  /* 
  
  var startPointArcOne = new paper.Point(100,100);
  var endPointArcOne = new paper.Point(0,100);
  var midPointArcOne = new paper.Point(40,50);
  
  var arcRight = new paper.Path.Arc(startPointArcOne, midPointArcOne, endPointArcOne);
  arcRight.fillColor = 'black';
  
  */
  
  //differentiating colors to tell objects apart
  /*
  longPiece.fillColor = 'red';
  midPiece.fillColor = 'blue';
  shortPiece.fillColor = 'black';
  largeSquare.fillColor = 'orange';
  smallSquare.fillColor = 'magenta';
  */
  
  //adding them to an array, all legos will pushed to a global array on intialization
  //var testArray = [loing];
  
  //hardcoded more lego items, to go along with rect 1 and rect 2
  
  
  //empty variable, will get assigned to on click.
  var currentSelection = new paper.Path();
  console.log(currentSelection);
  
  paper.view.draw();
  //variables for movement abilities
  var segment, path;
  var movePath = false;
  var hitOptions = {
	segments: true,
	stroke: true,
	fill: true,
	tolerance: 5
  };
  
  
  //picks up any paper path item it clicks on;
  tool.onMouseDown = function(event) {
    
    
    
    segment = path = null;
    var hitResult = paper.project.hitTest(event.point, hitOptions);
    
    if (!hitResult) {
      return;
    }
    
    if (event.modifiers.shift) {
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, event.point);
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, event.point);
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    }  
    console.log(hitResult.type);
  }
  
  
  //
  tool.onMouseDrag = function(event) {
    if (segment) {
      segment.point += event.delta;
      path.smooth();
    }
    else if (path) {
      path.position = event.point;
    }
  }
  
  //old work from p3 implementations
  /*

    // setting up the canvas and one paper tool
    var canvas = document.getElementById('myCanvas');
    paper.setup(canvas);
    var tool = new paper.Tool();
  
  var count = 0;

    // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  console.log(url);

  
    var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');
    var colors = ['black', 'green', 'red', 'pink', 'orange', 'purple', 'magenta', 'cyan', 'blue', 'gray'];
    
  var publicPath = new paper.Path();
  var isSmall = false;
  
  
  //array of paths, for the multiple users, 
  var peopleArray = [];
  
  for (i = 0; i < colors.length; i++) {
    peopleArray.push(new paper.Path());
  }
  
  var randomIndex = Math.floor((Math.random() * 10000) % colors.length);
    //publicPath.strokeColor = colors[randomIndex];
  
  
  //1C implementation here
  
  
  
  if (url == "https://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/draw/?size-small") {
    console.log("small url")
    isSmall = true;
    
    for (i=0; i< peopleArray.length; i++) {
      if (i != randomIndex) {
        console.log("setting path visibility to false");
        peopleArray[i].visible = false;
      }
    }
    
    
  }
  
  tool.onMouseDown = function(event) {
    
    peopleArray[randomIndex] = new paper.Path();
    
    //here have to make another socket send to flag if the thing is small
    
    var oneCdata = "[" + -2 + "," + randomIndex + "]";
    console.log(oneCdata);
    
    socket.send(oneCdata)
    
  }
  
  tool.onMouseDrag = function(event) {
   // console.log("dragging");
    
      var d = JSON.stringify(event.point);
    //console.log(d);
      d = d.substring(0, d.length -1);
      d = d + ',"' + colors[randomIndex] + '",' + randomIndex +']';
    console.log(d);
    
      socket.send(d);
    

  }
  
  tool.onMouseUp = function(event) {
    //publicPath = new paper.Path();
    //publicPath.strokeColor = 'white';
    
    peopleArray[randomIndex] = new paper.Path();
    
    var passFlag = "["+ randomIndex + ',' + -1 + "]";
    console.log(passFlag);
    socket.send(passFlag);
    
    //on mouse Up send a thing to the other arrays, and make sure the new piece is cleared.
    
  }
  
    socket.onmessage = function(data) {
      var c = JSON.parse(data.data);
      
      console.log(count);
      console.log(data.data);
      
      
      if (c[0] == -2) {
        if (isSmall && c[1] != randomIndex) {
          peopleArray[c[1]].visible = false;
          
        }
      }
      
      if (c[1] == -1) {
        peopleArray[c[0]] = new paper.Path();
        return;
      }
      
      //console.log(publicPath.segments);
      
      if (count == 0) {
        peopleArray[c[4]] = new paper.Path();
        peopleArray[c[4]].strokeColor = 'white';
        
        
      }
      else if (count == 1) {
        peopleArray[c[4]].removeSegment(peopleArray[c[4]].segments.length -1);
      }
      else if (count > 1) {
        //var c = JSON.parse(data.data);
      console.log(c);
        console.log(c[4], c[3]);
      peopleArray[c[4]].strokeColor = c[3];
      peopleArray[c[4]].add(new paper.Point(c[1],c[2]));
        
        
        console.log(count);
        
      }
      
      
      count = count + 1;
      paper.view.draw();
      
      
    }
    */

</script>
</html>
