{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>P4 Drawing</title>

    <link rel="stylesheet" type="text/css" href="{% static 'draw/vendor/bootstrap/css/bootstrap.min.css' %}">
    <script type="text/javascript" src="{% static 'draw/vendor/jquery/jquery-3.3.1.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'draw/vendor/paper/paper-full.min.js' %}"></script>
  <script type="text/javascript" src="https://cdn.rawgit.com/alexgibson/shake.js/master/shake.js"></script>
  

    <style type="text/css">
      
      /* Body element, flex display, justify content center, to center all following content*/
      body {
        display: flex;
        justify-content: center;
        flex-direction: column;
        
        
      }
      #myCanvas {
        height: 700px;
        width: 95%;
        margin: 0 auto;
      }
      
      /* This will be the bar to choose legos to drop onto the screen. */
      .legoBAR {
        margin-top: 20px;
        border: 2px solid blue;
        width: 95%;
        height:200px;
        margin-left: 30px;
        
        display: flex;
        justify-content: space-around;
      }
      
      .legoItem {
        height: 125px;
        width: 125px;
        margin-top:35px;
        display: flex;
        color: gold;
        flex-direction: column;
        justify-content: space-between;
        
        
      }
      
      .buttonContainer {
        margin: 0 auto;
        margin-bottom: 20px;
        
        width: 95%;
        display: flex;
        flex-direction: row;
        justify-content:space-around;
        margin-top: 20px;
      }
      
      .imageContainer {
        border: 2px solid green;
        margin-left: 30px;
        width: 80%;
        display: flex;
        margin-top: 10px;
        justify-content: space-evenly;
      }
      
      
    </style>

</head>
<body>
    <!-- You may change the dimensions of this canvas -->
    <canvas id="myCanvas"></canvas>
  
  <!--The "toolbar" which holds the different types of legos, div classes currently have placeholders,
        they will have buttons eventually which create new paper objects maybe in the bottom corner, and an undo button-->
  
  <div class="buttonContainer">
    <button onclick="createLargePiece()" class="largepiece">
         Large LEGO
      </button>
    <button onclick="createMidPiece()" class="largepiece">
         Medium LEGO
      </button>
    <button onclick="createSmallPiece()" class="largepiece">
         Small LEGO
      </button>
    <button onclick="createLargeSquare()" class="largepiece">
         Large Square
      </button>
    <button onclick="createSmallSquare()" class="largepiece">
         Small Square
      </button>
    
    <!--
    <button onclick="undo()">
         Undo
      </button> -->
    
  </div>
  <!--  ** Scrapping for now, not lining up visually and spending too much time on this **
  <div class="imageContainer">
    
    
    <div class="largeImage imageForClick"></div>
    <div class="mediumImage imageForClick"></div>
    <div class="smallImage imageForClick"></div>
    <div class="largeSimage imageForClick"></div>
    <div class="smallSimage imageForClick"></div>
    
    
    
  </div>
  -->
  
</body>
<script>
  
  //*** server is running HERE: http://p3-websockets-dpayne5-dpayne589733.codeanyapp.com:3000/draw/ *********

  //heck yea
  //nice
  var allLEGOS = [];
  var canvas = document.getElementById('myCanvas');
  var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');

  paper.setup(canvas);
  var tool = new paper.Tool();
  
  paper.view.draw();
  
  var segment, path;
  var movePath = false;
  
  // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  
  
  function makeFlagArray(index) {
    var flag = [index];
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    return flag;
    
  }
  
  function makeMouseDownSocketArray(event) {
    var flag = [-1];
    flag.push(event.point.x);
    flag.push(event.point.y);
    flag.push(event.point);
    flag.push(event.modifiers);
    flag.push(segment);
    flag.push(path);
    flag.push(movePath);
    
    return flag;
    
  }
  
  function createLargePiece() {
    socket.send(JSON.stringify(makeFlagArray(1))); 
  }
  
  
  function createSmallPiece() {
    socket.send(JSON.stringify(makeFlagArray(2))); 
  }
  
  function createMidPiece() {
    socket.send(JSON.stringify(makeFlagArray(3))); 
  }
  
  function createLargeSquare() {
    socket.send(JSON.stringify(makeFlagArray(4))); 
  }
  
  function createSmallSquare() {
    socket.send(JSON.stringify(makeFlagArray(5))); 
  }
  
  function undo() {
    socket.send(JSON.stringify(makeFlagArray(6))); 
  }
 
  //socket function, intended to be VERY large. Has switch cases for just about everything
  socket.onmessage = function(data) {
    
    var s = JSON.parse(data.data);
    console.log("parsing the info from new function");
    console.log(s);
    
    var x = parseInt(s[1]);
    var y = parseInt(s[2]);
    
    //generate random colors 
    function getRandomColor() {
      var options = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += options[Math.floor(Math.random() * 16)];
      }
      return color;
    }
    
    switch (parseInt(s[0])) {
      case 1:
        var newLP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(400,50));
        newLP.fillColor = 'black';
        s[3].push(newLP);
        console.log("looking at the items of s[3] now");
        console.log(s[3]);
        break;
      case 2:
        //do stuff
        var newMP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,50));
        newMP.fillColor = 'black';
        s[3].push(newMP);
        break;
      case 3:
        //do stuff
        var newSP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,50));
        newSP.fillColor = 'black';
        s[3].push(newMP);
        break;
      case 4:
        //do stuff
        var newLS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,200));
        s[3].push(newLS);
        newLS.fillColor = 'black';
        break;
      case 5:
        //do stuff
        var newSS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,100));
        s[3].push(newSS);
        newSS.fillColor = 'black';
        break;
      case 6:
        // *** currently the undo button does NOT work
        //do stuff
        //console.log("undo works");
        //allLEGOS[allLEGOS.length -1].fillColor = 'white';
        s[3][s[3].length -1].fillColor = 'white';
        var toDelete = s[3].pop();
        var toDelete = new paper.Path;
        
        
        break;
        
        
      case -1:
        console.log("in the socketMOUSEDOWN");
        //here we do things for mouseDown
        [s[5],s[6],s[7]] = socketMOUSEDOWN([s[3],s[4],s[5],s[6],s[7]]);
        console.log("s5 : ", s[5], "s6 : ", s[6], "s[7] : ", s[7]);

        break;
      case -2:
        //here we do things for mouseDrag
        console.log("in the socketMOUSEDRAG");
        socketMOUSEDRAG(s[4], s[3], s[5], s[6]);
        break;
        
      default:
        console.log("nothing happened");
        
        
    }
    
  }
  
  
  paper.view.draw();
  //variables for movement abilities
  
  
  
  var hitOptions = {
	segments: true,
	stroke: true,
	fill: true,
	tolerance: 5
  };
  
  
  //rolling mouseDown into one function, for websocket
  //needs to return segment, path, and movepath
  function socketMOUSEDOWN(eventpoint, modifiers, segment, path, movePath) {
    segment = path = null;
    
    var hitResult = paper.project.hitTest(eventpoint, hitOptions); //before was event.point
    
    if (!hitResult) {
      return [null, null, false];
    }
    
    if (modifiers.shift) { //before was event.modifiers
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, eventpoint);  //before was event.point
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, eventpoint); //before wa event.point
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    
    //need to return [segment, path, movepath]
    return [segment, path, movePath];
  }
  
  
  
  tool.onMouseDown = function(event) {
    
    //make [-1, event, segment, path, movePath] into JSON to pass to socketsend
    
    var s = event;
    //console.log("looking at returned pieces now for makeMOuse");
    
    //console.log(makeMouseDownSocketArray(s));
    
    //here the circular error is happening because of the event parameter. Need to find some workaround
    //can serialize the object, or just pull the relevant information
    //then need to look at what I need different
    
    socket.send(JSON.stringify(makeMouseDownSocketArray(s)));
    
    
    //Below is the original, which works only in your current browser!
    
    /*
    segment = path = null;
    
    
    var hitResult = paper.project.hitTest(event.point, hitOptions);
    
    if (!hitResult) {
      return;
    }
    
    if (event.modifiers.shift) {
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, event.point);
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, event.point);
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    */
  }
  
  
  
  function socketMOUSEDRAG(eDelta, ePoint, segment, path) {
    
    if (segment) {
      segment.point += eDelta;
      path.smooth();
    }
    else if (path) {
      path.position = ePoint;
    }
    
  }
  
  function makeMouseDragSocketArray(event) {
    var flag = [-2];
    flag.push(event.point.x);
    flag.push(event.point.y);
    flag.push(event.point);
    flag.push(event.delta);
    flag.push(segment);
    flag.push(path);
    
    
    return flag;
    
  }
  
  //
  tool.onMouseDrag = function(event) {
    
    var s = JSON.stringify(makeMouseDragSocketArray(event));
    socket.send(s);
    //below this line is old, working code for one browser window only
    /*
    if (segment) {
      segment.point += event.delta;
      path.smooth();
    }
    else if (path) {
      path.position = event.point;
    }
    */
  }
  
  //old work from p3 implementations
  /*

    // setting up the canvas and one paper tool
    var canvas = document.getElementById('myCanvas');
    paper.setup(canvas);
    var tool = new paper.Tool();
  
  var count = 0;

    // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  console.log(url);

  
    var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');
    var colors = ['black', 'green', 'red', 'pink', 'orange', 'purple', 'magenta', 'cyan', 'blue', 'gray'];
    
  var publicPath = new paper.Path();
  var isSmall = false;
  
  
  //array of paths, for the multiple users, 
  var peopleArray = [];
  
  for (i = 0; i < colors.length; i++) {
    peopleArray.push(new paper.Path());
  }
  
  var randomIndex = Math.floor((Math.random() * 10000) % colors.length);
    //publicPath.strokeColor = colors[randomIndex];
  
  
  //1C implementation here
  
  
  
  if (url == "https://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/draw/?size-small") {
    console.log("small url")
    isSmall = true;
    
    for (i=0; i< peopleArray.length; i++) {
      if (i != randomIndex) {
        console.log("setting path visibility to false");
        peopleArray[i].visible = false;
      }
    }
    
    
  }
  
  tool.onMouseDown = function(event) {
    
    peopleArray[randomIndex] = new paper.Path();
    
    //here have to make another socket send to flag if the thing is small
    
    var oneCdata = "[" + -2 + "," + randomIndex + "]";
    console.log(oneCdata);
    
    socket.send(oneCdata)
    
  }
  
  tool.onMouseDrag = function(event) {
   // console.log("dragging");
    
      var d = JSON.stringify(event.point);
    //console.log(d);
      d = d.substring(0, d.length -1);
      d = d + ',"' + colors[randomIndex] + '",' + randomIndex +']';
    console.log(d);
    
      socket.send(d);
    

  }
  
  tool.onMouseUp = function(event) {
    //publicPath = new paper.Path();
    //publicPath.strokeColor = 'white';
    
    peopleArray[randomIndex] = new paper.Path();
    
    var passFlag = "["+ randomIndex + ',' + -1 + "]";
    console.log(passFlag);
    socket.send(passFlag);
    
    //on mouse Up send a thing to the other arrays, and make sure the new piece is cleared.
    
  }
  
    socket.onmessage = function(data) {
      var c = JSON.parse(data.data);
      
      console.log(count);
      console.log(data.data);
      
      
      if (c[0] == -2) {
        if (isSmall && c[1] != randomIndex) {
          peopleArray[c[1]].visible = false;
          
        }
      }
      
      if (c[1] == -1) {
        peopleArray[c[0]] = new paper.Path();
        return;
      }
      
      //console.log(publicPath.segments);
      
      if (count == 0) {
        peopleArray[c[4]] = new paper.Path();
        peopleArray[c[4]].strokeColor = 'white';
        
        
      }
      else if (count == 1) {
        peopleArray[c[4]].removeSegment(peopleArray[c[4]].segments.length -1);
      }
      else if (count > 1) {
        //var c = JSON.parse(data.data);
      console.log(c);
        console.log(c[4], c[3]);
      peopleArray[c[4]].strokeColor = c[3];
      peopleArray[c[4]].add(new paper.Point(c[1],c[2]));
        
        
        console.log(count);
        
      }
      
      
      count = count + 1;
      paper.view.draw();
      
      
    }
    */

</script>
</html>
