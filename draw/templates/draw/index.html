{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>P4 Drawing</title>

    <link rel="stylesheet" type="text/css" href="{% static 'draw/vendor/bootstrap/css/bootstrap.min.css' %}">
    <script type="text/javascript" src="{% static 'draw/vendor/jquery/jquery-3.3.1.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'draw/vendor/paper/paper-full.min.js' %}"></script>
  <script type="text/javascript" src="https://cdn.rawgit.com/alexgibson/shake.js/master/shake.js"></script>
  
    <style type="text/css">
      
      /* Body element, flex display, justify content center, to center all following content*/
      body {
        display: flex;
        justify-content: center;
        flex-direction: column;
    }
      #myCanvas {
        height: 700px;
        width: 95%;
        margin: 0 auto;
        background: radial-gradient(circle, rgba(247,238,238,1) 8%, rgba(255,255,255,1) 41%, rgba(240,211,239,1) 90%, rgba(238,174,202,1) 100%);
      }
      
      /* This will be the bar to choose legos to drop onto the screen. */
      .legoBAR {
        margin-top: 20px;
        border: 2px solid blue;
        width: 95%;
        height:200px;
        margin-left: 30px;
        
        display: flex;
        justify-content: space-around;
      }
      
      .legoItem {
        height: 125px;
        width: 125px;
        margin-top:35px;
        display: flex;
        color: gold;
        flex-direction: column;
        justify-content: space-between;
        
        
      }
      
      .buttonContainer {
        margin: 0 auto;
        margin-bottom: 20px;
        
        width: 95%;
        display: flex;
        flex-direction: row;
        justify-content:space-around;
        margin-top: 20px;
      }
      
      .imageContainer {
        border: 2px solid green;
        margin-left: 30px;
        width: 80%;
        display: flex;
        margin-top: 10px;
        justify-content: space-evenly;
      }
      
      
    </style>

</head>
<body>
    <!-- You may change the dimensions of this canvas -->
    <canvas id="myCanvas"></canvas>
  
  <!--The "toolbar" which holds the different types of legos, div classes currently have placeholders,
        they will have buttons eventually which create new paper objects maybe in the bottom corner, and an undo button-->
  
  <div class="buttonContainer">
    <button onclick="createLargePiece()" class="largepiece">
         Large LEGO
      </button>
    <button onclick="createMidPiece()" class="largepiece">
         Medium LEGO
      </button>
    <button onclick="createSmallPiece()" class="largepiece">
         Small LEGO
      </button>
    <button onclick="createLargeSquare()" class="largepiece">
         Large Square
      </button>
    <button onclick="createSmallSquare()" class="largepiece">
         Small Square
      </button>
    
    <!--
    <button onclick="undo()">
         Undo
      </button> -->
    
  </div>
  <!--  ** Scrapping for now, not lining up visually and spending too much time on this **
  <div class="imageContainer">
    
    
    <div class="largeImage imageForClick"></div>
    <div class="mediumImage imageForClick"></div>
    <div class="smallImage imageForClick"></div>
    <div class="largeSimage imageForClick"></div>
    <div class="smallSimage imageForClick"></div>
    
    
    
  </div>
  -->
  
</body>
<script>
  
  //*** server is running HERE: http://p3-websockets-dpayne5-dpayne589733.codeanyapp.com:3000/draw/ *********

  var allLEGOS = [];
  var canvas = document.getElementById('myCanvas');
  var socket = new WebSocket('wss://p3-websockets-dpayne5-dpayne589733.codeanyapp.com/ws/draw');

  paper.setup(canvas);
  var tool = new paper.Tool();
  
  paper.view.draw();
  
  var segment, path;
  var movePath = false;
  var hitOptions = {
	segments: true,
	stroke: true,
	fill: true,
	tolerance: 10
  };
  
    tool.onMouseDown = function(event) {
      
      segment = path = null;
      var hitResult = paper.project.hitTest(event.point, hitOptions);
      
      if (!hitResult) {
          return;
          }
      
      //taken care of
      if (hitResult) {
        path = hitResult.item;
        //socket send hitResult.item;
        updateClientPath(hitResult.item); //currently doesnt work, gives back a different ID from the item imported, also not the same
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
        
        //socket send to make this happen across clients as well
      }
      /*
      var s = event;
    segment = path = null;
    
    
    var hitResult = paper.project.hitTest(event.point, hitOptions);
    
    //here
    
    
    //lets try and send this hit result through.....
    console.log(hitResult);
    //looking at results of hitResult;
    //here this is initialize {'fill } etc etc....so this is the problem
    console.log(hitResult);
    
    if (!hitResult) {
      return;
    }
    
    
    if (event.modifiers.shift) {
      
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
		if (hitResult.type == 'segment') {
      console.log("************EVENTMOD SEGMENT********")
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
      console.log("************EVENTMOD STROKE********")
			var location = hitResult.location;
			segment = path.insert(location.index + 1, event.point);
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      //need to send to the socket that path = this item *** IMPORTANT ***
      console.log("HIT RESULT ITEM IS:::", hitResult.item);
      //console.log(hitResult.item.id);
      console.log("HIT RESULT ITEM ID IS :::", hitResult.item.id);
      
      
      
      
      if (hitResult.type == 'segment') {
        console.log("************EVENTMOD SEGMENT********")
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stroke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, event.point);
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        console.log("************MOVECHILD LAYER********")
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    */

    
  }
    
    
    
    
    function updateClientPath(hitResultPath) {
      var toPass = JSON.stringify(hitResultPath); //what we want to pass to the websocket
      console.log("THE PATH BEFORE ITS SENT ::: ", path);
      socket.send(toPass);
    }
  
  
    
    
    
    
    tool.onMouseDrag = function(event) {
      
      //segment piece not important
    if (segment) {
      segment.point += event.delta;
      path.smooth();
    }
      
      
      
    else if (path) {
      
      
      makeMouseDragTwo(event.point, path.id);
      //console.log("what is da path: " + path + " " + path.id);
      //path.position = event.point
      
    }
    
    
  }
    
    function makeMouseDragTwo(eventPoint, id) {
      var flag = [-2];
      flag.push(id);
      flag.push(eventPoint);
      socket.send(JSON.stringify(flag));
      console.log("STRINGIFYD FOR FLAG OF MOUSEDRAG");
      console.log(JSON.stringify(flag));
  }
  
  
  
  
  
  // getting the URL (you may want to use for Exercise 3)
    var url = window.location.href;
  
  
  function makeFlagArray(index) {
    var flag = [index];
    console.log("what is this flag thingy: " + flag);
    console.log(typeof flag);
    flag.push(event.clientX);
    flag.push(event.clientY - 100);
    flag.push(allLEGOS);
    flag.push(getRandomID);
    console.log("flag after adding lego piece: " + flag)
    return flag;
  }
 
  
  
  
  
  
  
  
  
  function makeMouseDownSocketArray(event) {
    
    var test = "-1";
    test += event.point.toString();
    test += event.modifiers.shift.toString;
    test += event.item.toString();

    var flag = [-1];
    flag.push(event.point.x);
    flag.push(event.point.y);
    flag.push(event.point);
    flag.push(event.modifiers.shift);
    flag.push(segment);
    flag.push(path);
    flag.push(movePath);
    flag.push(allLEGOS);
    flag.push(event.item); //this is s[9]
    
    return flag;
    
  }
  
  function createLargePiece() {
    socket.send(JSON.stringify(makeFlagArray(1))); 
  }
  function createSmallPiece() {
    //console.log("printing out all lego arrays:" + allLEGOS);
    socket.send(JSON.stringify(makeFlagArray(2)));
    //console.log("after adding:" + allLEGOS);
  }
  function createMidPiece() {
    socket.send(JSON.stringify(makeFlagArray(3))); 
  }
  function createLargeSquare() {
    socket.send(JSON.stringify(makeFlagArray(4))); 
  }
  function createSmallSquare() {
    socket.send(JSON.stringify(makeFlagArray(5))); 
  }
  function undo() {
    socket.send(JSON.stringify(makeFlagArray(6))); 
  }
      
  //generate random colors function
  function getRandomColor() {
      var options = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += options[Math.floor(Math.random() * 16)];
      }
      return color;
    }
  function getRandomID() {
    var randID = Math.floor((Math.random() * 10000000) % 1000);
    return randID;
  }
  
  
  
  //socket function, intended to be VERY large. Has switch cases for just about everything
  socket.onmessage = function(data) {
    
    var s = JSON.parse(data.data);
    
    if (s[0] == 'Path') {
      console.log("HERE WE ARE SENDING THE PATH JSON!!! EXCITING!!!");
      //path = paper.importJSON(data.data);
      console.log("THE PATH INSIDE OF SOCKET ONMESSAGE ON UPDATE ::::", path);
      paper.project.activeLayer.addChild(paper.importJSON(data.data));
      
    }
    
    var x = parseInt(s[1]);
    var y = parseInt(s[2]);
    
    switch (parseInt(s[0])) {
        //making a new LargeLego
      case 1:
        console.log(s);
        var newLP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(400,50));
        newLP.fillColor = getRandomColor();
        s[3].push(newLP);
        
        break;
        //making new medium lego
      case 2:
        //do stuff
        var newMP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,50));
        newMP.fillColor = getRandomColor();
        s[3].push(newMP);
        return newMP;
        break;
        //making new smallLego
      case 3:
        //do stuff
        var newSP = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,50));
        newSP.fillColor = getRandomColor();
        s[3].push(newMP);
        return newSP;
        break;
        //making new LargeSquare
      case 4:
        //do stuff
        var newLS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(200,200));
        s[3].push(newLS);
        newLS.fillColor = getRandomColor();
        return newLS;
        break;
        //making new SmallSquare
      case 5:
        //do stuff
        var newSS = new paper.Path.Rectangle(new paper.Point(x,y), new paper.Size(100,100));
        s[3].push(newSS);
        newSS.fillColor = getRandomColor();
        return newSS;
        break;
        
        //undo button, currently not working
      case 6:
        
        s[3][s[3].length -1].fillColor = 'white';
        var toDelete = s[3].pop();
        var toDelete = new paper.Path;    
        break;

        //mouseDown socketSend
      case -1:
        socketMOUSEDOWN(s[3], s[4], s[5], s[6], s[7], s[8], s[9]);
        
        break;
        
        //mouseDrag socketSend
      case -2:
        console.log("all paths array::: ", allLEGOS);
        
        console.log("THE PATH IN CASE -2 IS :::: ", path);
        console.log("PATH ID IS :: ", path.id);

        var b = new paper.Point(s[2][1], s[2][2]); 
        var ID = s[1]
        console.log("ID SENT BY JSON IS::: ", ID);
        var newpath = paper.project.getItems({
        id: ID
        
      });
        
        //so this is making a new point, and then taking the ID, and getting the item based off of ID, and assigning
        //to it a new location. Now since this isnt *happening* on any screen, it must be getting the wrong ID,
        
        
        
        //*** testing path IDs
        
        
        path.position = b;
        
        newpath.position = b;
        
        
        
        break;
        
      default:
        
        
    }
    
  }
  
  
  paper.view.draw();
  //variables for movement abilities
  
  
  function socketMOUSEDOWN(eventpoint, modifiers, segment, path, movePath, allLEGOS, eventItem) {
    segment = path = null;
    
    //var hitResult = paper.project.hitTest(eventpoint, hitOptions);
    //before was event.point
    var hitResult = eventItem[1];
    
    if (!hitResult) {
      return [null, null, false];
    }
    if (modifiers) { //before was event.modifiers
      if (hitResult.type == 'segment') {
        hitResult.segment.remove();
      }
    }
    
    if (hitResult) {
		path = hitResult.item;
      console.log("HIT RESULT ITEM IS ::: ", hitResult.item);
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
		} else if (hitResult.type == 'stroke') {
			var location = hitResult.location;
			segment = path.insert(location.index + 1, eventpoint);  //before was event.point
			path.smooth();
		}
	}
    
    if (hitResult) {
      path = hitResult.item;
      if (hitResult.type == 'segment') {
        segment = hitResult.segment;
      }
      else if (hitResult.type == 'stoke') { //this should be the hit result.segment deal
        var location = hitResult.location;
        segment = path.insert(location.index+1, eventpoint); //before wa event.point
        path.smooth();
      }
      
      movePath = hitResult.type == 'fill';
      if (movePath) {
        paper.project.activeLayer.addChild(hitResult.item);
      }
    } 
    paper.view.draw();
    
    //need to return [segment, path, movepath]
    console.log("BEFORE RETURN<> SEGMENT PATH movePAth: ", segment, path, movePath);
    return [segment, path, movePath];
  }

  
  //
  
  
  
  
  
  

</script>
</html>
